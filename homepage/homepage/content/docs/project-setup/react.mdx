export const metadata = { title: "Installation" };

import { CodeGroup } from "@/components/forMdx";

# Installation and Setup

Add Jazz to your React application in minutes. This setup covers standard React apps, Next.js, and gives an overview of experimental SSR approaches. 

Integrating Jazz with React is straightforward. You'll define data schemas that describe your application's structure, then wrap your app with a provider that handles sync and storage. The whole process takes just three steps:

1. [Install dependencies](#install-dependencies)
2. [Write your schema](#write-your-schema)
3. [Wrap your app in `<JazzProvider />`](#standard-react-setup)

Looking for complete examples? Check out our [example applications](/examples) for chat apps, collaborative editors, and more.

## Install dependencies

First, install the required packages:

<CodeGroup>
```bash
pnpm install jazz-react jazz-tools
```
</CodeGroup>

## Write your schema

Define your data schema using [CoValues](/docs/schemas/covalues) from `jazz-tools`.

<CodeGroup>
```tsx twoslash
// schema.ts
import { Account, co } from "jazz-tools";

export class MyAppAccount extends Account {
  name = co.string;
}
```
</CodeGroup>

See [CoValues](/docs/schemas/covalues) for more information on how to define your schema.

## Standard React Setup

Wrap your application with `<JazzProvider />` to connect to the Jazz network and define your data schema:

<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { Account } from "jazz-tools";

export class MyAppAccount extends Account {}
// @filename: app.tsx
import * as React from "react";
import { createRoot } from 'react-dom/client';

function App() {
    return <div>Hello, world!</div>;
}
// ---cut---
// app.tsx
import { JazzProvider } from "jazz-react";
import { MyAppAccount } from "./schema";

createRoot(document.getElementById("root")!).render(
  <JazzProvider
    sync={{ peer: "wss://cloud.jazz.tools/?key=you@example.com" }}
    AccountSchema={MyAppAccount}
  >
    <App />
  </JazzProvider>
);

// Register your Account schema to enhance TypeScript support
declare module "jazz-react" {
  interface Register {
    Account: MyAppAccount;
  }
}
```
</CodeGroup>

This setup handles:
- Connection to the Jazz sync server
- Schema registration for type-safe data handling
- Local storage configuration

With this in place, you're ready to start using Jazz hooks in your components. [Learn how to access and update your data](/docs/using-covalues/subscription-and-loading#subscription-hooks).

## Next.js Integration

### Client-side Only (Easiest)

The simplest approach for Next.js is client-side only integration:

<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { Account } from "jazz-tools";

export class MyAppAccount extends Account {}
// @filename: app.tsx
import * as React from "react";
// ---cut---
// app.tsx
"use client" // Mark as client component

import { JazzProvider } from "jazz-react";
import { MyAppAccount } from "./schema";

export function JazzWrapper({ children }: { children: React.ReactNode }) {
  return (
    <JazzProvider
      sync={{ peer: "wss://cloud.jazz.tools/?key=you@example.com" }}
      AccountSchema={MyAppAccount}
    >
      {children}
    </JazzProvider>
  );
}
```
</CodeGroup>

Remember to mark any component that uses Jazz hooks with `"use client"`:

<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { Account, co } from "jazz-tools";

export class MyAppAccount extends Account {
  name = co.string;
}
// @filename: Profile.tsx
import * as React from "react";
import { MyAppAccount } from "./schema";

declare module "jazz-react" {
  interface Register {
    Account: MyAppAccount;
  }
}
// ---cut---
// Profile.tsx
"use client"; // [!code ++]

import { useAccount } from "jazz-react";

export function Profile() {
  const { me } = useAccount();
    
  return <div>Hello, {me?.name}</div>;
}
```
</CodeGroup>

### SSR Support (Experimental)

For server-side rendering, Jazz offers experimental approaches:

- Pure SSR
- Hybrid SSR + Client Hydration

#### Pure SSR

Use Jazz in server components by directly loading data with `CoValue.load()`.

{/*
<CodeGroup>
```tsx twoslash
// @errors: 18047
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}

export class MyCollection extends CoList.Of(co.ref(MyItem)) {}
// @filename: PublicData.tsx
import * as React from "react";
import { ID } from "jazz-tools";
const collectionID = "co_z123" as ID<MyCollection>;
// ---cut---
// Server Component (no "use client" directive)
import { MyCollection, MyItem } from "./schema";

export default async function PublicData() {
  // Load data directly in the server component
  const items = await MyCollection.load(collectionID);
        
  if (!items) {
    return <div>Loading...</div>;
  }
    
  return (
    <ul>
      {items.map(item => (
        item ? <li key={item.id}>{item.title}</li> : null
      ))}
    </ul>
  );
}
```
</CodeGroup>
*/}

This works well for public data accessible to the server account.

#### Hybrid SSR + Client Hydration

For more complex cases, you can pre-render on the server and hydrate on the client:

1. Create a shared rendering component.

{/*
<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}
// @filename: ItemList.tsx
import * as React from "react";
import { MyItem } from "./schema";
// ---cut---
// ItemList.tsx - works in both server and client contexts
export function ItemList({ items }: { items: MyItem[] }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
}
```
</CodeGroup>
*/}

2. Create a client hydration component.

{/*
<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}
export class MyCollection extends CoList.Of(co.ref(MyItem)) {}
// @filename: ItemList.tsx
import * as React from "react";
import { MyItem } from "./schema";

export function ItemList({ items }: { items: MyItem[] }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
}
// @filename: ItemListHydrator.tsx
// ItemListHydrator.tsx
import * as React from "react";
import { useCoState } from "jazz-react";
import { ID } from "jazz-tools";
const myCollectionID = "co_z123" as ID<MyCollection>;
// ---cut---
"use client"

import { MyCollection, MyItem } from "./schema";
import { ItemList } from "./ItemList";
export function ItemListHydrator({ initialItems }: { initialItems: MyItem[] }) {
  // Hydrate with real-time data once client loads
  const myCollection = useCoState(MyCollection, myCollectionID);

  // Filter out nulls for type safety
  const items = Array.from(myCollection?.values() || []).filter(
    (item): item is MyItem => !!item
  );
    
  // Use server data until client data is available
  const displayItems = items || initialItems;
    
  return <ItemList items={displayItems} />;
}
```
</CodeGroup>
*/}

3. Create a server component that pre-loads data.

{/*
<CodeGroup>
```tsx twoslash
// @filename: schema.ts
import { co, CoList, CoMap } from "jazz-tools";

export class MyItem extends CoMap {
  title = co.string;
}

export class MyCollection extends CoList.Of(co.ref(MyItem)) {}
// @filename: ItemList.tsx
import * as React from "react";
import { MyItem } from "./schema";

export function ItemList({ items }: { items: MyItem[] }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
}
// @filename: ItemListHydrator.tsx
// ItemListHydrator.tsx
import * as React from "react";
import { useCoState } from "jazz-react";
import { ID } from "jazz-tools";
const myCollectionID = "co_z123" as ID<MyCollection>;
// ---cut---
"use client"

import { MyCollection, MyItem } from "./schema";
import { ItemList } from "./ItemList";
export function ItemListHydrator({ initialItems }: { initialItems: MyItem[] }) {
  // Hydrate with real-time data once client loads
  const myCollection = useCoState(MyCollection, myCollectionID);

  // Filter out nulls for type safety
  const items = Array.from(myCollection?.values() || []).filter(
    (item): item is MyItem => !!item
  );
    
  // Use server data until client data is available
  const displayItems = items || initialItems;
    
  return <ItemList items={displayItems} />;
}
// @filename: ServerItemPage.tsx
import * as React from 'react';
import { ID } from "jazz-tools";
import { MyCollection, MyItem } from "./schema";
import { ItemListHydrator } from "./ItemListHydrator";
const myCollectionID = "co_z123" as ID<MyCollection>;
// ---cut---
// ServerItemPage.tsx
export default async function ServerItemPage() {
  // Pre-load data on the server
  const initialItems = await MyCollection.load(myCollectionID);

  // Filter out nulls for type safety
  const items = Array.from(initialItems?.values() || []).filter(
    (item): item is MyItem => !!item
  );
    
  // Pass to client hydrator
  return <ItemListHydrator initialItems={items} />;
}
```
</CodeGroup>
*/}

This approach gives you the best of both worlds: fast initial loading with server rendering, plus real-time updates on the client.

## Further Reading

- [Schemas](/docs/schemas/covalues) - Learn about defining your data model
- [Provider Configuration](/docs/project-setup/providers) - Learn about other configuration options for Providers
- [Authentication](/docs/authentication/overview) - Set up user authentication
- [Sync and Storage](/docs/sync-and-storage) - Learn about data persistence

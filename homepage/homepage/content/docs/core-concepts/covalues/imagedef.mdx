import { CodeGroup, ContentByFramework, ExpoLogo, ReactLogo, RNLogo, SvelteLogo, TabbedCodeGroup, TabbedCodeGroupItem } from "@/components/forMdx";

export const metadata = {
  description: "ImageDefinition is a CoValue for storing images with built-in UX features."
};

# ImageDefinition

`ImageDefinition` is a specialized CoValue designed specifically for managing images in Jazz applications. It extends beyond basic file storage by supporting a blurry placeholder, built-in resizing, and progressive loading patterns.

<ContentByFramework framework={['react-native', 'react-native-expo']}>
**Note**: This guide applies to both Expo and framework-less React Native implementations.
</ContentByFramework>

Beyond `ImageDefinition`, Jazz offers higher-level functions and components that make it easier to use images:
- [`createImage()`](#creating-images) - function to create an `ImageDefinition` from a file
- [`loadImage`, `loadImageBySize`, `highestResAvailable`](#displaying-images) - functions to load and display images
<ContentByFramework framework={['react', 'svelte','react-native','react-native-expo']}>
- [`Image`](#displaying-images) - Component to display an image
</ContentByFramework>

<ContentByFramework framework="react">
The [Image Upload example](https://github.com/gardencmp/jazz/tree/main/examples/image-upload) demonstrates use of images in Jazz.
</ContentByFramework>

<ContentByFramework framework="svelte">
The [Chat example](https://github.com/gardencmp/jazz/tree/main/examples/chat-svelte) includes an implementation of ImageDefinitions in Svelte.
</ContentByFramework>

<ContentByFramework framework={["react-native"]}>
## Installation [!framework=react-native]
Jazz's images implementation is based on `@bam.tech/react-native-image-resizer`. Check the [installation guide](/docs/react-native/project-setup#install-dependencies) for more details.
</ContentByFramework>

<ContentByFramework framework={["react-native-expo"]}>
## Installation [!framework=react-native-exp]
Jazz's images implementation is based on `expo-image-manipulator`. Check the [installation guide](/docs/react-native-expo/project-setup#install-dependencies) for more details.
</ContentByFramework>

## Creating Images

The easiest way to create and use images in your Jazz application is with the `createImage()` function:

<TabbedCodeGroup id="create-image" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" icon={<ReactLogo />} value="react" preferWrap>
```ts twoslash
import { Account, Group, ImageDefinition } from "jazz-tools";

declare const me: {
  $jazz: {
    owner: Account | Group;
  };
  profile: {
    image: ImageDefinition;
  };
};

// ---cut---
import { createImage } from "jazz-tools/media";

// Create an image from a file input
async function handleFileUpload(event: Event) {
  const input = event.target as HTMLInputElement | null;
  const file = input?.files?.[0];
  if (file) {
    // Creates ImageDefinition with a blurry placeholder, limited to 1024px on the longest side, and multiple resolutions automatically
    const image = await createImage(file, {
      owner: me.$jazz.owner,
      maxSize: 1024,
      placeholder: "blur",
      progressive: true,
    });

    // Store the image in your application data
    me.profile.image = image;
  }
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" icon={<SvelteLogo />} value="svelte" preferWrap>
```ts twoslash
import { Account, Group, ImageDefinition } from "jazz-tools";

declare const me: {
  $jazz: {
    owner: Account | Group;
  };
  profile: {
    image: ImageDefinition;
  };
};

// ---cut---
import { createImage } from "jazz-tools/media";

// Create an image from a file input
async function handleFileUpload(event: Event) {
  const input = event.target as HTMLInputElement | null;
  const file = input?.files?.[0];
  if (file) {
    // Creates ImageDefinition with a blurry placeholder, limited to 1024px on the longest side, and multiple resolutions automatically
    const image = await createImage(file, {
      owner: me.$jazz.owner,
      maxSize: 1024,
      placeholder: "blur",
      progressive: true,
    });

    // Store the image in your application data
    me.profile.image = image;
  }
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="React Native" icon={<RNLogo />} value="react-native" preferWrap>
```ts twoslash
import { Account, Group, ImageDefinition } from "jazz-tools";

declare const me: {
  $jazz: {
    owner: Account | Group;
  };
  profile: {
    image: ImageDefinition;
  };
};
// @ts-ignore
// ---cut---
import { launchImageLibrary } from 'react-native-image-picker';
import { createImage } from "jazz-tools/media";


async function handleImagePicker() {
  // Use your favorite image picker library to get the image URI
  const result = await launchImageLibrary({
    mediaType: 'photo',
    quality: 1,
  });

  if (!result.didCancel && result.assets && result.assets.length > 0) {
    // Creates ImageDefinition with a blurry placeholder, limited to 1024px on the longest side, and multiple resolutions automatically.
    // See the options below for more details.
    const image = await createImage(result.assets[0].uri, {
      owner: me.$jazz.owner,
      maxSize: 1024,
      placeholder: "blur",
      progressive: true,
    });

    // Store the image
    me.profile.image = image;
  }
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="React Native (Expo)" icon={<ExpoLogo />} value="react-native-expo" preferWrap>
```ts twoslash
import { Account, Group, ImageDefinition } from "jazz-tools";

declare const me: {
  $jazz: {
    owner: Account | Group;
  };
  profile: {
    image: ImageDefinition;
  };
};

// @ts-ignore
// ---cut---
import { launchImageLibrary } from 'react-native-image-picker';
import { createImage } from "jazz-tools/media";

async function handleImagePicker() {
  // Use your favorite image picker library to get the image URI
  const result = await launchImageLibrary({
    mediaType: 'photo',
    quality: 1,
  });

  if (!result.didCancel && result.assets && result.assets.length > 0) {
    // Creates ImageDefinition with a blurry placeholder, limited to 1024px on the longest side, and multiple resolutions automatically.
    // See the options below for more details.
    const image = await createImage(result.assets[0].uri, {
      owner: me.$jazz.owner,
      maxSize: 1024,
      placeholder: "blur",
      progressive: true,
    });

    // Store the image
    me.profile.image = image;
  }
}
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

The `createImage()` function:
- Creates an `ImageDefinition` with the right properties
- Generates a small placeholder for immediate display
- Creates multiple resolution variants of your image
- Returns the created `ImageDefinition`

### Configuration Options

<CodeGroup>
```ts twoslash
import type { ImageDefinition, Group, Account } from "jazz-tools";
// ---cut---
declare function createImage(
  image: Blob | File | string,
  options: {
    owner?: Group | Account;
    placeholder?: "blur" | false;
    maxSize?: number;
    progressive?: boolean;
  }): Promise<ImageDefinition>
```
</CodeGroup>

#### `image`

The image to create an `ImageDefinition` from.
<ContentByFramework framework={['react', 'svelte', 'vanilla']}>
 This can be a `Blob` or a `File`.
</ContentByFramework>
<ContentByFramework framework={['react-native', 'react-native-expo']}>
  This must be a `string` with the file path.
</ContentByFramework>

#### `owner`

The owner of the `ImageDefinition`. This is used to control access to the image. See [Groups as permission scopes](/docs/permissions-and-sharing/overview) for more information on how to use groups to control access to images.

#### `placeholder`

The placeholder is a base64 encoded image that is displayed while the image is loading. Currently, only `"blur"` is a supported.

#### `maxSize`

The image generation process includes a maximum size setting that controls the longest side of the image. A built-in resizing feature is applied based on this setting.

#### `progressive`

The progressive loading pattern is a technique that allows images to load incrementally, starting with a small version and gradually replacing it with a larger version as it becomes available. This is useful for improving the user experience by showing a placeholder while the image is loading.

Passing `progressive: true` to `createImage()` will create internal smaller versions of the image for future uses.

### Create multiple resized copies

To create multiple resized copies of an original image for better layout control, you can use the `createImage` function multiple times with different parameters for each desired size. Hereâ€™s an example of how you might implement this:

<CodeGroup>
```ts twoslash
declare const myBlob: Blob;
// ---cut---
import { co } from "jazz-tools";
import { createImage } from "jazz-tools/media";

// Jazz Schema
const ProductImage = co.map({
  image: co.image(),
  thumbnail: co.image(),
});

const mainImage = await createImage(myBlob);
const thumbnail = await createImage(myBlob, {
  maxSize: 100,
});

// or, in case of migration, you can use the original stored image.
const newThumb = await createImage(mainImage!.original!.toBlob()!, {
  maxSize: 100,
});

const imageSet = ProductImage.create({
  image: mainImage,
  thumbnail,
});
```
</CodeGroup>

### Creating images on the server

We provide a `createImage` function to create images from server side using the same options as the browser version, using the package `jazz-tools/media/server`. Check the [server worker](/docs/server-side/setup) documentation to learn more.

The resize features are based on the `sharp` library, then it is requested as peer dependency in order to use it.

<TabbedCodeGroup id="install-sharp" default="pnpm" savedPreferenceKey="package-manager">
  <TabbedCodeGroupItem label="npm">
```sh
npm install sharp
```
  </TabbedCodeGroupItem>
  <TabbedCodeGroupItem label="pnpm">
```sh
pnpm install sharp
```
  </TabbedCodeGroupItem>
</TabbedCodeGroup>

<CodeGroup className="mt-4">
```ts
import fs from "node:fs";
import { createImage } from "jazz-tools/media/server";

const image = fs.readFileSync(new URL("./image.jpg", import.meta.url));

await createImage(image, {
  // options
});
```
</CodeGroup>

## Displaying Images

<ContentByFramework framework={['react', 'svelte', 'react-native', 'react-native-expo']}>
To use the stored ImageDefinition, there are two ways: declaratively, using the `Image` component, and imperatively, using the static methods.
</ContentByFramework>

<ContentByFramework framework={['react', 'svelte', 'react-native', 'react-native-expo']}>
  The Image component is the best way to let Jazz handle the image loading.
### `<Image>` component [!framework=react,svelte,react-native,react-native-expo]
<TabbedCodeGroup id="image-component" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" icon={<ReactLogo />} value="react" preferWrap>
```tsx
import * as React from "react";
import { co } from "jazz-tools";
const ImageDef = co.image();
// ---cut---
import { Image } from "jazz-tools/react";

function GalleryView({ image }: { image: co.loaded<typeof ImageDef> }) {
  return (
    <div className="image-container">
      <Image imageId={image.id} alt="Profile" width={600} />
    </div>
  );
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" icon={<SvelteLogo />} value="svelte" preferWrap>
```svelte twoslash
<script lang="ts">
  import { ImageDefinition, type Loaded } from 'jazz-tools';
  import { Image } from 'jazz-tools/svelte';
  let { image }: { image: Loaded<typeof ImageDefinition> } = $props();
</script>

<Image
  imageId={image.id}
  alt=""
  class="h-auto max-h-[20rem] max-w-full rounded-t-xl mb-1"
/>

```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="React Native" icon={<RNLogo />} value="react-native" preferWrap>
```tsx twoslash
import React from 'react';
import { co, ImageDefinition } from 'jazz-tools';

// ---cut---
import { Image } from "jazz-tools/react-native";
import { StyleSheet } from "react-native";

function GalleryView({ image }: {
  image: co.loaded<typeof ImageDefinition>
}) {
  return (
    <Image
      imageId={image.$jazz.id}
      style={styles.galleryImage}
      width={400}
      resizeMode="cover"
    />
  );
}

const styles = StyleSheet.create({
  galleryImage: {
    width: '100%',
    height: 200,
    borderRadius: 8,
  }
});
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="React Native (Expo)" icon={<ExpoLogo />} value="react-native-expo" preferWrap>
```tsx twoslash
import { Image } from "jazz-tools/expo";
import { StyleSheet } from "react-native";

function GalleryView({ image }) {
  return (
    <Image
      imageId={image.id}
      style={styles.galleryImage}
      width={400}
      resizeMode="cover"
    />
  );
}

const styles = StyleSheet.create({
  galleryImage: {
    width: '100%',
    height: 200,
    borderRadius: 8,
  }
});
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

The `Image` component handles:
- Showing a placeholder while loading, if generated
- Automatically selecting the appropriate resolution, if generated with progressive loading
- Progressive enhancement as higher resolutions become available, if generated with progressive loading
- Determining the correct width/height attributes to avoid layout shifting
- Cleaning up resources when unmounted

The component's props are:

</ContentByFramework>
<ContentByFramework framework={["react", "svelte"]}>
<CodeGroup>
```ts
export type ImageProps = Omit<
  HTMLImgAttributes,
  "src" | "srcset" | "width" | "height"
> & {
  imageId: string;
  width?: number | "original";
  height?: number | "original";
};
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework={['react-native', 'react-native-expo']}>
<CodeGroup>
```ts
export type ImageProps = Omit<
  RNImageProps,
  "width" | "height" | "source"
> & {
  imageId: string;
  width?: number | "original";
  height?: number | "original";
};
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework={['react','svelte','react-native','react-native-expo']}>
#### Width and Height props [!framework=react,svelte,react-native,react-native-expo]

The `width` and `height` props are used to control the best resolution to use but also the width and height attributes of the image tag.

Let's say we have an image with a width of 1920px and a height of 1080px.

<CodeGroup>
```tsx
<Image imageId="123" />
// Image with the highest resolution available

<Image imageId="123" width="original" height="original" />
// Image with width 1920 and height 1080

<Image imageId="123" width="600" />
// Better to avoid, as may be rendered with 0 height

<Image imageId="123" width="600" height="original" />
// Keeps the aspect ratio (height: 338)

<Image imageId="123" width="original" height="600" />
// As above, aspect ratio is maintained, width is 1067

<Image imageId="123" width="600" height="600" />
// Renders as a 600x600 square
```
</CodeGroup>

If the image was generated with progressive loading, the `width` and `height` props will determine the best resolution to use.

</ContentByFramework>
<ContentByFramework framework={['react', 'svelte']}>
#### Lazy loading [!framework=react,svelte]

The `Image` component supports lazy loading with the [same options as the native browser `loading` attribute].(https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/img#loading). It will generate the blob url for the image when the browser's viewport reaches the image.

<CodeGroup>
```tsx
<Image imageId="123" width="original" height="original" loading="lazy" />
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework={['react', 'svelte','react-native','react-native-expo']}>
### Imperative Usage [!framework=react,svelte,react-native,react-native-expo]
</ContentByFramework>

Like other CoValues, `ImageDefinition` can be used to load the object.

<CodeGroup>
```tsx twoslash
import { ImageDefinition } from "jazz-tools";

const image = await ImageDefinition.load("123", {
  resolve: {
    original: true,
  },
});

if(image) {
  console.log({
    originalSize: image.originalSize,
    placeholderDataUrl: image.placeholderDataURL,
    original: image.original, // this FileStream may be not loaded yet
  });
}
```
</CodeGroup>

`image.original` is a `FileStream` and its content can be read as described in the [FileStream](/docs/core-concepts/covalues/filestreams#reading-from-filestreams) documentation.

Since FileStream objects are also CoValues, they must be loaded before use. To simplify loading, if you want to load the binary data saved as Original, you can use the `loadImage` function.

<CodeGroup>
```ts twoslash
declare const imageDefinitionOrId: string;
// ---cut---
import { loadImage } from "jazz-tools/media";

const image = await loadImage(imageDefinitionOrId);
if(image === null) {
  throw new Error("Image not found");
}

const img = document.createElement("img");
img.width = image.width;
img.height = image.height;
img.src = URL.createObjectURL(image.image.toBlob()!);
img.onload = () => URL.revokeObjectURL(img.src);
```
</CodeGroup>

If the image was generated with progressive loading, and you want to access the best-fit resolution, use `loadImageBySize`. It will load the image of the best resolution that fits the wanted width and height.

<CodeGroup>
```ts twoslash
declare const imageDefinitionOrId: string;
// ---cut---
import { loadImageBySize } from "jazz-tools/media";

const image = await loadImageBySize(imageDefinitionOrId, 600, 600); // 600x600

if(image) {
  console.log({
    width: image.width,
    height: image.height,
    image: image.image,
  });
}
```
</CodeGroup>


If want to dynamically listen to the _loaded_ resolution that best fits the wanted width and height, you can use the `subscribe` and the `highestResAvailable` function.

<CodeGroup>
```ts
import { ImageDefinition } from "jazz-tools";
// function highestResAvailable(image: ImageDefinition, wantedWidth: number, wantedHeight: number): FileStream | null
import { highestResAvailable } from "jazz-tools/media";

const image = await ImageDefinition.load(imageId);

if(image === null) {
  throw new Error("Image not found");
}

const img = document.createElement("img");
img.width = 600;
img.height = 600;

// start with the placeholder
if(image.placeholderDataURL) {
  img.src = image.placeholderDataURL;
}

// then listen to the image changes
image.$jazz.subscribe({}, (image) => {
  const bestImage = highestResAvailable(image, 600, 600);

  if(bestImage) {
    // bestImage is again a FileStream
    const blob = bestImage.image.toBlob();
    if(blob) {
      const url = URL.createObjectURL(blob);
      img.src = url;
      img.onload = () => URL.revokeObjectURL(url);
    }
  }
});
```
</CodeGroup>

## Custom image manipulation implementations

To manipulate images (like placeholders, resizing, etc.), `createImage()` uses different implementations depending on the environment.

<ContentByFramework framework={['react', 'svelte']}>
On the browser, image manipulation is done using the `canvas` API.
</ContentByFramework>
<ContentByFramework framework="react-native">
On React Native, image manipulation is done using the `@bam.tech/react-native-image-resizer` library.
</ContentByFramework>
<ContentByFramework framework="react-native-expo">
On Expo, image manipulation is done using the `expo-image-manipulator` library.
</ContentByFramework>

If you want to use a custom implementation, you can use the `createImageFactory` function in order create your own `createImage` function and use your preferred image manipulation library.

<CodeGroup>
```ts
import { createImageFactory } from "jazz-tools/media";

const createImage = createImageFactory({
    createFileStreamFromSource: async (source, owner) => {
        // ...
    },
    getImageSize: async (image) => {
        // ...
    },
    getPlaceholderBase64: async (image) => {
        // ...
    },
    resize: async (image, width, height) => {
        // ...
    },
});
```
</CodeGroup>

## Best Practices

- **Set image sizes** when possible to avoid layout shifts
- **Use placeholders** (like LQIP - Low Quality Image Placeholders) for instant rendering
- **Prioritize loading** the resolution appropriate for the current viewport
- **Consider device pixel ratio** (window.devicePixelRatio) for high-DPI displays
- **Always call URL.revokeObjectURL** after the image loads to prevent memory leaks
import { CodeGroup, ContentByFramework } from "@/components/forMdx";
import { Alert } from "@garden-co/design-system/src/components/atoms/Alert";

export const metadata = {
  description: "Learn how to use branching and merging in Jazz for collaborative editing with conflict resolution and private branches."
};

# Version Control

Jazz provides built-in version control through branching and merging, allowing multiple users to work on the same CoValue simultaneously without conflicts. This enables collaborative editing workflows where users can create private branches, make changes, and merge them back to the main version.

## Working with branches

### Creating Branches

To create a branch, use the `unstable_branch` option when loading a CoValue:

<CodeGroup>
```ts
const branch = await Project.load(projectId, {
  unstable_branch: { name: "feature-branch" }
});
```
</CodeGroup>

<ContentByFramework framework={["react", "react-native", "expo"]}>
You can also create a branch via the `useCoState` hook:

<CodeGroup>
```ts
const branch = useCoState(Project, projectId, {
  unstable_branch: { name: "feature-branch" }
});
```
</CodeGroup>
</ContentByFramework>
<ContentByFramework framework={["svelte"]}>
You can also create a branch via `CoState`:

<CodeGroup>
```ts
const branch = new CoState(Project, projectId, {
  unstable_branch: { name: "feature-branch" }
});
```
</CodeGroup>
</ContentByFramework>

You can also include nested CoValues in your branch by using a [`resolve` query](/docs/using-covalues/subscription-and-loading#resolve-queries). All of the nested CoValues will have their own branched versions created, and you can access them in the same way you would normally access a deeply loaded property.

<Alert variant="info" className="mt-4 flex gap-2 items-center">
  In case you create a separate reference to a nested CoValue (for example by loading it by its ID), you will need to specify the branch you wish to load.
</Alert>

### Making Changes

Once you have a branch, you can make changes using the same methods as the original CoValue:

<ContentByFramework framework={["react", "react-native", "expo", "vue", "vanilla"]}>  
<CodeGroup>
```tsx 
function EditProject({ projectId, currentBranchName }) {
  const project = useCoState(Project, projectId, {
    resolve: {
      tasks: { $each: true }
    },
    unstable_branch: {
      name: currentBranchName,
    },
  });

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Won't be visible on main until merged
    project.$jazz.set("title", e.target.value);
  };

  const handleTaskTitleChange = (index: number, e: React.ChangeEvent<HTMLInputElement>) => {
    const task = project.tasks[index];

    // The task is also part of the branch because we used the `resolve` option
    // with `tasks: { $each: true }`
    // so the changes won't be visible on main until merged
    task?.$jazz.set("title", e.target.value);
  };

  return (
    <form onSubmit={handleSave}>
      {/* Edit form fields */}
    </form>
  );
}
```
</CodeGroup>
</ContentByFramework>
<ContentByFramework framework={["svelte"]}>
<CodeGroup>
```svelte
<script lang="ts">
  import { CoState } from 'jazz-tools/svelte';
  import { Project } from './schema.js';

  let projectId = $state<string>();
  let currentBranchName = $state<string>('main');

  const project = new CoState(Project, () => projectId, () => ({
    resolve: {
      tasks: { $each: true }
    },
    unstable_branch: currentBranchName === 'main' ? undefined : { name: currentBranchName }
  }));

  function handleTitleChange(e: Event) {
    const target = e.target as HTMLInputElement;
    // Won't be visible on main until merged
    project.current?.$jazz.set("title", target.value);
  }

  function handleTaskTitleChange(index: number, e: Event) {
    const target = e.target as HTMLInputElement;
    const task = project.current?.tasks[index];

    // The task is also part of the branch because we used the `resolve` option
    // with `tasks: { $each: true }`
    // so the changes won't be visible on main until merged
    task?.$jazz.set("title", target.value);
  }
</script>

<form>
  <!-- Edit form fields -->
  <input 
    type="text" 
    value={project.current?.title || ''} 
    oninput={handleTitleChange}
  />
  
  {#each project.current?.tasks || [] as task, index}
    <input 
      type="text" 
      value={task.title || ''} 
      oninput={(e) => handleTaskTitleChange(index, e)}
    />
  {/each}
</form>
```
</CodeGroup>
</ContentByFramework>

### Merging

To merge a branch back to the main version, call `unstable_merge()`:

<CodeGroup>
```tsx 
function handleSave() {
  // Merge the branch changes back to main
  project.$jazz.unstable_merge();
  router.navigate("/");
}
```
</CodeGroup>

All the changes made to the branch will be merged into the main CoValue, preserving both author and timestamp.

Calling `unstable_merge()` will merge every change done in the project and the loaded tasks.

The merge is idempotent, so you can merge the same branch multiple times without changing the result.

The merge operation is scoped, so if you call `unstable_merge()` on a task, only the changes to the task will be merged

<CodeGroup>
```tsx 
function handleTaskSave(index: number) {
  const task = project.tasks[index];
  // Only the changes to the task will be merged
  task?.$jazz.unstable_merge();
}
```
</CodeGroup>


## Conflict Resolution

When conflicts occur (the same field is modified in both the branch and main), Jazz uses a "last writer wins" strategy:

<CodeGroup>
```tsx
// Branch modifies priority to "high"
branch.$jazz.applyDiff({ priority: "high" });

// Meanwhile, main modifies priority to "urgent"
originalProject.$jazz.applyDiff({ priority: "urgent" });

// Merge the branch
branch.$jazz.unstable_merge();

// Main's value wins ("urgent") because it was written later
console.log(originalProject.priority); // "urgent"
```
</CodeGroup>

## Private branches

When the owner is not specified, the branch has the same permissions as the main values.

You can also create a private branch by providing a group owner.

<CodeGroup>
```tsx 
// Create a private group for the branch
const privateGroup = Group.create();

const privateBranch = useCoState(Project, projectId, {
  unstable_branch: { 
    name: "private-edit", 
    owner: privateGroup 
  }
});

// Only members of privateGroup can see the branch content
// The sync server cannot read the branch content
```
</CodeGroup>


You can use private branches both to make the changes to the branches "private" until merged, or to give controlled write access to a group of users.

Only users with both write access to the main branch and read access to the private branch have the rights to merge the branch.

## Branch Identification

You can get the current branch information from the `$jazz` field.

<CodeGroup>
```ts 
const branch = await Project.load(projectId, {
  unstable_branch: { name: "feature-branch" }
});

// Branch ID is the same as source
console.log(branch.$jazz.branchName); // "feature-branch"
console.log(branch.$jazz.isBranch); // true
```
</CodeGroup>
